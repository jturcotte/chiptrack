// Copyright Â© 2021 Jocelyn Turcotte <turcotte.j@gmail.com>
// SPDX-License-Identifier: MIT

export struct SongPatternData {
    number: int,
    // For range selection (not yet supported)
    selected: bool,
}
export struct PatternInstrumentData {
    id: string,
    // Internal sequencer name to avoid ambiguity, but same as instrument:u8 elsewhere.
    synth_index: int,
    notes: [int],
}
export struct StepData {
    press: bool,
    release: bool,
    note: int,
    param0_set: bool,
    param0_val: int,
    param1_set: bool,
    param1_val: int,
}
export struct InstrumentData {
    id: string,
    active: bool,
    muted: bool,
    param0: int,
    param1: int,
}
export struct NoteData {
    note_number: int,
    key_pos: int,
    is_black: bool,
    active: bool,
}
export struct ChannelTraceNote {
    channel: int,
    start_tick: int,
    num_ticks: int,
    octave: int,
    key_pos: int,
    cent_adj: float,
    is_black: bool,
    volume: float,
}
export struct ChannelActiveNote {
    trace: ChannelTraceNote,
    note_name: string,
}
export struct Settings {
    sync_enabled: bool,
}
export struct SongSettings {
    frames_per_step: int,
}

// State shared by the desktop and gba UIs is put here in a
// global to avoid having to duplicate them in the separate root components.
export global GlobalUI {
    // param0, param1, press, release
    in-out property<int> selected_column: 2;
    in-out property<int> selected_step: 0;
    in-out property<bool> x_pressed: false;
    in-out property<bool> z_pressed: false;
    in-out property<KeyEvent> last_pressed_key;
    in-out property<bool> playing: false;
    in property<bool> recording: true;
    out property<bool> pin_selection_to_active: false;

    public function toggle_play(song_mode: bool) {
        playing = !playing;

        if playing {
            // In song mode pin the selection to the active pattern/step
            // so that the playback position is kept visible.
            pin_selection_to_active = song_mode;

            // Reset the playback step position to the beginning of the pattern.
            GlobalEngine.activate_step(0);
        } else {
            // When not playing, keep the active step pinned to the selection so that
            // notes can be recorded on the selected step.
            // Also reset the playback step position to the selected song pattern and step.
            pin_selection_to_active = true;
            GlobalEngine.activate_song_pattern(GlobalEngine.sequencer_song_pattern_selected);
            GlobalEngine.activate_step(selected_step);
        }

        GlobalEngine.set_playing(playing, song_mode);
    }

    public function cycle_step_colum(forward: bool) {
        if forward && selected_column < 3 {
            selected_column += 1;
        } else if (!forward && selected_column > 0){
            selected_column -= 1;
        }
    }

    public function select_song_pattern(song_pattern: int) {
        if playing {
            pin_selection_to_active = false;
        } else {
            // When not playing, make sure that the selected pattern is also activated
            // so that recording notes happen in the selected pattern and that playback will start there.
            GlobalEngine.activate_song_pattern(song_pattern);
        }
        GlobalEngine.display_song_pattern(song_pattern);
    }

    public function select_next_song_pattern(forward: bool) {
        if forward && GlobalEngine.sequencer_song_pattern_selected + 1 < GlobalEngine.sequencer_song_patterns.length {
            select_song_pattern(GlobalEngine.sequencer_song_pattern_selected + 1);
        } else if !forward && GlobalEngine.sequencer_song_pattern_selected > 0 {
            select_song_pattern(GlobalEngine.sequencer_song_pattern_selected - 1);
        }
    }

    public function select_step(step: int) {
        if playing {
            pin_selection_to_active = false;
        } else {
            // This updates the step receiving key record events when not playing.
            GlobalEngine.activate_step(step);
        }
        selected_step = step;
    }

    public function select_next_step(forward: bool) {
        if playing {
            pin_selection_to_active = false;
        }
        if forward {
            if selected_step < 15 {
                select_step(selected_step + 1);
            } else {
                // FIXME: Report return val issue and re-use select_next_song_pattern
                if GlobalEngine.sequencer_song_pattern_selected + 1 < GlobalEngine.sequencer_song_patterns.length {
                    select_step(0);
                    select_next_song_pattern(true);
                }
            }
        } else {
            if selected_step > 0 {
                select_step(selected_step - 1);
            } else {
                if GlobalEngine.sequencer_song_pattern_selected > 0 {
                    select_step(15);
                    select_next_song_pattern(false);
                }
            }
        }
    }

    public function update_selected_step() {
        if playing && pin_selection_to_active {
            selected_step = GlobalEngine.sequencer_step_active;
        }
    }

}



export global GlobalEngine {
    in-out property<[SongPatternData]> sequencer_song_patterns: [
        {number: 0},
        {number: 1, selected: true},
        {number: 0},
        {number: 1},
        {number: 0},
        {number: 1},
        {number: 2},
        {number: 3}];
    // The selection cursor, used for keeping it scrolled into the view.
    in-out property<int> sequencer_song_pattern_selected: 0;
    in-out property<int> sequencer_song_pattern_active: 0;

    in-out property<[string]> script_instrument_ids: [];
    in-out property<int> sequencer_pattern_instruments_len: 0;
    in-out property<[PatternInstrumentData]> sequencer_pattern_instruments: [
        {id: "",
            notes: [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]},
        {id: "",
            notes: [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]},
        {id: "",
            notes: [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]},
        {id: "",
            notes: [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]},
        {id: "",
            notes: [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]},
        {id: "",
            notes: [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]},
    ];
    in-out property<[StepData]> sequencer_steps: [
        {press: true, note: 65},
        {press: false}, {press: false}, {press: false},
        {press: true, release: true, note: 65},
        {press: false}, {press: false}, {press: false},
        {press: true, note: 65},
        {press: false}, {press: false}, {press: false},
        {press: false, release: true},
        {press: false}, {press: false}, {press: false}];
    in-out property<int> sequencer_step_active: 8;

    in-out property<[InstrumentData]> instruments: [
        {id: "1", active: false}, {active: true}, {active: false}, {active: false},
        {active: false}, {active: false}, {active: false}, {active: false},
        {active: false}, {active: false}, {active: false}, {active: false},
        {active: false}, {active: false}, {active: false}, {active: false},
        {id: "17", active: false}, {active: false}, {active: false}, {active: false},
        {active: false}, {active: false}, {active: false}, {active: false},
        {active: false}, {active: false}, {active: false}, {active: false},
        {active: false}, {active: false}, {active: false}, {active: false},
        ];

    in-out property<int> displayed_instrument: 0;
    pure callback phase_visualization_tick(float) -> float;

    in-out property<int> last_synth_tick: -1;
    in-out property<[ChannelTraceNote]> synth_trace_notes: [
        { channel: 0, start_tick: 123, num_ticks: 1, octave: 3, key_pos: 0, is_black: false, volume: 1.0, },
        { channel: 0, start_tick: 123, num_ticks: 1, octave: 3, key_pos: 3, is_black: true, volume: 1.0, },
        { channel: 0, start_tick: 122, num_ticks: 1, octave: 3, key_pos: 0, is_black: false, volume: 1.0, },
        { channel: 0, start_tick: 121, num_ticks: 1, octave: 3, key_pos: 0, is_black: false, volume: 1.0, },
    ];
    in-out property<[ChannelActiveNote]> synth_active_notes: [
        { trace: { channel: 0, start_tick: 123, num_ticks: 1, octave: 3, key_pos: 0, is_black: false, volume: 1.0, }, note_name: "C", },
        { trace: { channel: 0, start_tick: 123, num_ticks: 1, octave: 3, key_pos: 3, is_black: true, volume: 1.0, }, note_name: "F#", },
    ];

    callback note_pressed(int);
    callback note_released(int);
    callback set_erasing(bool);
    callback display_instrument(int);
    callback cycle_instrument(int, int);
    callback cycle_pattern_instrument(bool);
    callback cycle_step_note_start(int);
    callback cycle_step_note_end(int);
    callback cycle_step_note(int, bool, bool);
    callback cycle_instrument_param_start();
    callback cycle_instrument_param_end();
    callback cycle_instrument_param(int, bool);
    callback cycle_step_param_start(int, int);
    callback cycle_step_param_end(int, int);
    callback cycle_step_param(int, int, bool, bool);
    callback cycle_song_pattern_start();
    callback cycle_song_pattern_start_with_new();
    callback cycle_song_pattern(bool);
    callback cut_step_note(int);
    callback cut_step_param(int, int);
    callback toggle_mute_instrument(int);
    callback toggle_step(int);
    callback toggle_step_release(int);
    callback activate_step(int);
    callback set_playing(/*playing*/ bool, /*song_mode*/ bool);
    callback record_clicked(bool);
    callback display_song_pattern(int);
    callback remove_last_song_pattern();
    callback clone_displayed_song_pattern();
    callback activate_song_pattern(int);
    callback save_project();
    callback export_project_as_gba_sav();
    callback mute_instruments();
}

export global GlobalSettings {
    in-out property<Settings> settings: {
        sync_enabled: false,
    };
    in-out property<SongSettings> song_settings: {
        frames_per_step: 7,
    };
    callback settings_changed(Settings);
    callback song_settings_changed(SongSettings);
}

export global GlobalUtils {
    pure callback get_midi_note_name(int) -> string;
    pure callback get_midi_note_short_name(int) -> string;
    pure callback to_signed_hex(int) -> string;
}

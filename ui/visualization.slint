// Copyright Â© 2021 Jocelyn Turcotte <turcotte.j@gmail.com>
// SPDX-License-Identifier: MIT

import {
    ChannelTraceNote,
    ChannelActiveNote,
    GlobalEngine
} from "globals.slint";

component OctaveIndicator inherits Rectangle {
    border_width: 1px;
    border_color: black;
    background: white;
    Rectangle {
        background: black;
        y: 1 * parent.height / 7px * 1px - self.height / 2;
        height: parent.height / 7 * 0.8;
        width: 60%;
    }
    Rectangle {
        background: black;
        y: 2 * parent.height / 7px * 1px - self.height / 2;
        height: parent.height / 7 * 0.8;
        width: 60%;
    }
    Rectangle {
        background: black;
        y: 3 * parent.height / 7px * 1px - self.height / 2;
        height: parent.height / 7 * 0.8;
        width: 60%;
    }
    Rectangle {
        background: black;
        y: 5 * parent.height / 7px * 1px - self.height / 2;
        height: parent.height / 7 * 0.8;
        width: 60%;
    }
    Rectangle {
        background: black;
        y: 6 * parent.height / 7px * 1px - self.height / 2;
        height: parent.height / 7 * 0.8;
        width: 60%;
    }
}

component ScaleSeparators inherits Path {
    viewbox-width: self.width / 1px;
    viewbox-height: self.height / 1px;
    stroke: #e8e8e8;
    stroke-width: 1px;

    MoveTo { x: 10; y: parent.viewbox-height * 1 / 7; }
    LineTo { x: parent.viewbox-width - 10; y: parent.viewbox-height * 1 / 7; }
    MoveTo { x: 10; y: parent.viewbox-height * 2 / 7; }
    LineTo { x: parent.viewbox-width - 10; y: parent.viewbox-height * 2 / 7; }
    MoveTo { x: 10; y: parent.viewbox-height * 3 / 7; }
    LineTo { x: parent.viewbox-width - 10; y: parent.viewbox-height * 3 / 7; }
    MoveTo { x: 10; y: parent.viewbox-height * 4 / 7; }
    LineTo { x: parent.viewbox-width - 10; y: parent.viewbox-height * 4 / 7; }
    MoveTo { x: 10; y: parent.viewbox-height * 5 / 7; }
    LineTo { x: parent.viewbox-width - 10; y: parent.viewbox-height * 5 / 7; }
    MoveTo { x: 10; y: parent.viewbox-height * 6 / 7; }
    LineTo { x: parent.viewbox-width - 10; y: parent.viewbox-height * 6 / 7; }
}

component OctaveSeparator inherits Path {
    viewbox-width: self.width / 1px;
    viewbox-height: self.height / 1px;
    stroke: #d8d8d8;
    stroke-width: 2px;

    MoveTo { x: 10; y: parent.viewbox-height + 1; }
    LineTo { x: parent.viewbox-width - 10; y: parent.viewbox-height + 1; }
}


export component Visualization inherits Rectangle {
    property<[color]> chan_colors: [
        Colors.rgb(192, 0, 0),
        Colors.rgb(0, 192, 0),
        Colors.rgb(64, 0, 192),
        Colors.rgb(0, 64, 192)
        ];
    property<int> visible_octaves: 4;
    property<length> note_height: self.height / (7 * visible_octaves + 2);
    // One note spacer, and the real note
    property<length> noise_area_height: note_height * 2;

    background: #f8f8f8;
    border_width: 1px;
    border_color: #e8e8e8;

    for i in root.visible_octaves:
    HorizontalLayout {
        OctaveIndicator {
            width: 5%;
            height: root.note_height * 7;
            y: parent.height - root.noise_area_height - self.height * (i + 1);
        }

        Rectangle {
            ScaleSeparators {
                width: 100%;
                height: root.note_height * 7;
                y: parent.height - root.noise_area_height - root.note_height * 7 * (i + 1);
            }
            OctaveSeparator {
                width: 100%;
                height: root.note_height * 7;
                y: parent.height - root.noise_area_height - root.note_height * 7 * (i + 1);
            } 
        }
    }

    HorizontalLayout {
        Rectangle {
            z: 1;
            width: 5%;

            for note[idx] in GlobalEngine.synth_active_notes:
            Rectangle {
                border-radius: self.width;
                width: self.height;
                height: root.note_height * 3;
                x: parent.width - self.width / 2;
                y: parent.height
                    - (note.trace.octave == 0 && note.trace.key_pos == 0
                        ? root.note_height
                        : root.noise_area_height
                            + ((note.trace.octave - 2) * 7 + note.trace.key_pos + note.trace.cent_adj + (note.trace.is_black ? 1.5 : 1)) * root.note_height
                        )
                    + root.note_height / 2 - self.height / 2;
                background: white;
                border-color: chan_colors[note.trace.channel];
                border-width: 2px;
                Text {
                    width: 100%;
                    height: 100%;
                    text: note.note_name;
                    font_size: min(self.width, self.height) / 2.5;
                    color: chan_colors[note.trace.channel];
                    horizontal_alignment: center;
                    vertical_alignment: center;
                }
            }
        }
        trace_container := Rectangle {
            property<length> tick_width: self.width / (6 * 16 * 2);
            // The animated current_tick_number won't exactly match with the time when old traces
            // are going to be removed from the model from the sequencer and then reach the UI
            // thread. So clip the container.
            clip: true;
            Rectangle {
                // We animate x using Slint's current animation tick, but the traces are positioned based
                // on synth ticks. Both of them are set to pass through ~59.7 ticks per second, but they don't
                // necessarily start from 0 at the same time.
                // To keep the animation smooth, the phasing will be constant once determined at the beginning.
                x: GlobalEngine.phase_visualization_tick(
                    // 4194304 Hz / 70224 Hz per frame = ~59.7 frames per second
                    animation_tick() * (4194304/70224) / 1000ms
                    ) * trace_container.tick_width;

                for note[idx] in GlobalEngine.synth_trace_notes:
                Rectangle {
                    width: trace_container.tick_width * note.num_ticks;
                    height: root.note_height * 0.8;
                    x: -note.start_tick * trace_container.tick_width - self.width;
                    y: parent.height
                        - (note.octave == 0 && note.key_pos == 0
                            ? root.note_height
                            : root.noise_area_height + ((note.octave - 2) * 7 + note.key_pos + note.cent_adj + (note.is_black ? 1.5 : 1) - 0.1) * root.note_height
                            );
                    background: chan_colors[note.channel];
                    opacity: note.volume;
                }
            }
        }
    }
}
